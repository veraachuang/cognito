/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./js/sidebar.js":
/*!***********************!*\
  !*** ./js/sidebar.js ***!
  \***********************/
/***/ (() => {

eval("// sidebar.js\n\nconsole.log('[Cognito] Sidebar script loaded');\n\n// Main Application Class\nclass SidebarApp {\n  constructor() {\n    this.activeTab = 'upload'; // Default tab\n    this.lastWritingUpdate = null;\n    this.elements = this.initElements();\n    this.initEventListeners();\n    this.switchTab(this.activeTab);\n    this.notifyParentReady();\n  }\n\n  // DOM Elements Initialization\n  initElements() {\n    return {\n      closeBtn: document.getElementById('close-sidebar'),\n      tabButtons: document.querySelectorAll('.tab-button'),\n      tabPanels: document.querySelectorAll('.tab-panel'),\n      braindumpInput: document.getElementById('braindump-input'),\n      uploadButton: document.getElementById('upload-button'),\n      fileInput: document.getElementById('file-input'),\n      uploadDropzone: document.getElementById('upload-dropzone'),\n      uploadedFiles: document.getElementById('uploaded-files'),\n      analyzeButton: document.getElementById('analyze-button'),\n      outlineContainer: document.getElementById('outline-container'),\n      regenerateOutline: document.getElementById('regenerate-outline'),\n      applyOutline: document.getElementById('apply-outline'),\n      promptsContainer: document.getElementById('prompts-container'),\n      wordCount: document.getElementById('word-count'),\n      readingTime: document.getElementById('reading-time'),\n      gradeLevel: document.getElementById('grade-level'),\n      writingStyle: document.getElementById('writing-style'),\n      vocabularyLevel: document.getElementById('vocabulary-level'),\n      sentenceStructure: document.getElementById('sentence-structure'),\n      clarityScore: document.getElementById('clarity-score'),\n      engagementScore: document.getElementById('engagement-score'),\n      recommendationsContainer: document.getElementById('recommendations-container')\n    };\n  }\n\n  // Initialize Event Listeners\n  initEventListeners() {\n    // Window message handler\n    window.addEventListener('message', this.handleWindowMessage.bind(this));\n\n    // Close button handler\n    if (this.elements.closeBtn) {\n      this.elements.closeBtn.addEventListener('click', () => {\n        window.parent.postMessage({ action: 'closeSidebar' }, '*');\n      });\n    }\n\n    // Tab button handlers\n    if (this.elements.tabButtons) {\n      this.elements.tabButtons.forEach(button => {\n        button.addEventListener('click', () => {\n          this.switchTab(button.dataset.tab);\n        });\n      });\n    }\n\n    // Braindump input handler\n    if (this.elements.braindumpInput) {\n      this.elements.braindumpInput.addEventListener('input', (e) => {\n        this.analyzeText(e.target.value);\n        this.updateLastWritingTime();\n      });\n    }\n\n    // File upload handlers\n    this.initFileUploadListeners();\n\n    // Outline button handlers\n    this.initOutlineButtonListeners();\n  }\n\n  // Initialize file upload related listeners\n  initFileUploadListeners() {\n    const { uploadButton, fileInput, uploadDropzone } = this.elements;\n\n    if (uploadButton && fileInput) {\n      uploadButton.addEventListener('click', () => {\n        fileInput.click();\n      });\n\n      fileInput.addEventListener('change', (e) => {\n        this.handleFiles(e.target.files);\n      });\n    }\n\n    if (uploadDropzone) {\n      uploadDropzone.addEventListener('dragover', (e) => {\n        e.preventDefault();\n        uploadDropzone.classList.add('drag-over');\n      });\n\n      uploadDropzone.addEventListener('dragleave', () => {\n        uploadDropzone.classList.remove('drag-over');\n      });\n\n      uploadDropzone.addEventListener('drop', (e) => {\n        e.preventDefault();\n        uploadDropzone.classList.remove('drag-over');\n        this.handleFiles(e.dataTransfer.files);\n      });\n    }\n  }\n\n  // Initialize outline button listeners\n  initOutlineButtonListeners() {\n    const { analyzeButton, regenerateOutline, applyOutline, outlineContainer } = this.elements;\n\n    if (analyzeButton) {\n      analyzeButton.addEventListener('click', async () => {\n        const text = this.elements.braindumpInput?.value.trim();\n        if (!text) return;\n\n        try {\n          const cursorPosition = await this.getCursorPosition();\n          const data = await this.generateOutline(text, cursorPosition);\n          this.displayOutline(data.outline);\n          this.switchTab('outline');\n          \n          window.parent.postMessage({\n            action: 'applyOutline',\n            data: { \n              outline: data.outline,\n              cursor_position: cursorPosition\n            }\n          }, '*');\n        } catch (error) {\n          console.error('Error generating outline:', error);\n          alert('Failed to generate outline. Please try again.');\n        }\n      });\n    }\n\n    if (regenerateOutline) {\n      regenerateOutline.addEventListener('click', () => {\n        if (analyzeButton) analyzeButton.click();\n      });\n    }\n\n    if (applyOutline && outlineContainer) {\n      applyOutline.addEventListener('click', () => {\n        const outlineItems = Array.from(outlineContainer.querySelectorAll('.outline-section'))\n          .map(section => ({\n            title: section.querySelector('h3')?.textContent.replace(/^\\d+\\.\\s/, '') || '',\n            points: Array.from(section.querySelectorAll('li')).map(li => li.textContent)\n          }));\n\n        window.parent.postMessage({\n          action: 'applyOutline',\n          data: { outline: outlineItems }\n        }, '*');\n      });\n    }\n  }\n\n  // Handle window messages\n  handleWindowMessage(event) {\n    const { action, data, features, tab } = event.data;\n\n    if (action === 'switchTab' && tab) {\n      this.switchTab(tab);\n    } else if (action === 'liveTextUpdate') {\n      this.updateAnalysisTab(data);\n      if (features) {\n        this.updateTextFeatures(features);\n      }\n      this.updateLastWritingTime();\n    }\n  }\n\n  // Switch between tabs\n  switchTab(tabId) {\n    console.log('Switching to tab:', tabId);\n    \n    // Update active tab state\n    this.activeTab = tabId;\n\n    // Update button states\n    this.elements.tabButtons?.forEach(btn => {\n      if (btn.dataset.tab === tabId) {\n        btn.classList.add('active');\n      } else {\n        btn.classList.remove('active');\n      }\n    });\n    \n    // Update panel visibility\n    this.elements.tabPanels?.forEach(panel => {\n      if (panel.id === tabId) {\n        panel.classList.add('active');\n        panel.style.display = 'block';\n      } else {\n        panel.classList.remove('active');\n        panel.style.display = 'none';\n      }\n    });\n\n    // Initialize tab-specific functionality\n    if (tabId === 'braindump' && this.elements.braindumpInput) {\n      this.analyzeText(this.elements.braindumpInput.value);\n    }\n  }\n\n  // Update text features display\n  updateTextFeatures(features) {\n    const { wordCount, readingTime } = this.elements;\n    \n    if (wordCount) {\n      wordCount.textContent = features.wordCount;\n    }\n    \n    if (readingTime) {\n      readingTime.textContent = features.readingTime;\n    }\n  }\n\n  // Update timestamp of last writing change\n  updateLastWritingTime() {\n    this.lastWritingUpdate = Date.now();\n    localStorage.setItem('lastWritingUpdate', this.lastWritingUpdate);\n  }\n\n  // Handle file uploads\n  handleFiles(files) {\n    const { uploadedFiles } = this.elements;\n    if (!uploadedFiles || !files || !files.length) return;\n    \n    // Display files in the list\n    Array.from(files).forEach(file => {\n      const fileItem = document.createElement('div');\n      fileItem.className = 'file-item';\n      fileItem.innerHTML = `\n        <span class=\"file-icon\"><i class=\"fas fa-file-alt\"></i></span>\n        <span class=\"file-name\">${file.name}</span>\n      `;\n      uploadedFiles.appendChild(fileItem);\n    });\n\n    // Send files to content script\n    window.parent.postMessage({\n      action: 'uploadFiles',\n      data: { files: Array.from(files) }\n    }, '*');\n  }\n\n  // Get cursor position from parent window\n  async getCursorPosition() {\n    return new Promise((resolve) => {\n      window.parent.postMessage({ action: 'getCursorPosition' }, '*');\n      \n      const messageHandler = (event) => {\n        if (event.data.action === 'cursorPosition') {\n          window.removeEventListener('message', messageHandler);\n          resolve(event.data.position);\n        }\n      };\n      \n      window.addEventListener('message', messageHandler);\n    });\n  }\n\n  // Generate outline via API\n  async generateOutline(text, cursorPosition) {\n    const response = await fetch('http://127.0.0.1:5000/api/generate-outline', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json'\n      },\n      mode: 'cors',\n      body: JSON.stringify({ \n        text,\n        cursor_position: cursorPosition\n      })\n    });\n\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n\n    return await response.json();\n  }\n\n  // Display outline in the UI\n  displayOutline(outline) {\n    const { outlineContainer } = this.elements;\n    if (!outlineContainer) return;\n    \n    if (!outline || !outline.sections) {\n      outlineContainer.innerHTML = '<p class=\"error\">Failed to generate outline. Please try again.</p>';\n      return;\n    }\n\n    let html = '<div class=\"outline-sections\">';\n\n    outline.sections.forEach((section, index) => {\n      html += `\n        <div class=\"outline-section\">\n          <h3>${index + 1}. ${section.title}</h3>\n          <ul>\n            ${section.key_points.map(point => `<li>${point}</li>`).join('')}\n          </ul>\n          ${section.suggested_length ? \n            `<p class=\"suggested-length\">Suggested length: ~${section.suggested_length} words</p>` : ''}\n        </div>\n      `;\n    });\n\n    html += '</div>';\n    outlineContainer.innerHTML = html;\n  }\n\n  // Text Analysis Methods\n  analyzeText(text) {\n    if (!text) return;\n    \n    const parsed = this.parseText(text);\n    const analysis = this.calculateTextMetrics(parsed);\n    \n    this.updateAnalysisDisplay(analysis);\n    \n    if (this.isWriterStuck(text, parsed)) {\n      this.generateWritingPrompts();\n    }\n  }\n  \n  // Parse text into components for analysis\n  parseText(text) {\n    const trimmed = text.trim();\n    const words = trimmed.split(/\\s+/).filter(Boolean);\n    const sentences = trimmed.split(/[.!?]+/).filter(s => s.trim().length > 0);\n    const syllables = this.countSyllables(trimmed);\n    \n    return { \n      text: trimmed,\n      words,\n      sentences,\n      syllables\n    };\n  }\n  \n  // Calculate various text metrics\n  calculateTextMetrics(parsed) {\n    const { words, sentences, syllables } = parsed;\n    \n    // Basic metrics\n    const wordCount = words.length;\n    const readingTime = Math.ceil(wordCount / 200);\n    \n    // Grade level metrics\n    const wordsPerSentence = wordCount / Math.max(1, sentences.length);\n    const syllablesPerWord = syllables / Math.max(1, wordCount);\n    const gradeLevel = Math.round(0.39 * wordsPerSentence + 11.8 * syllablesPerWord - 15.59);\n    \n    // Writing style metrics\n    const avgWordLength = words.reduce((sum, w) => sum + w.length, 0) / Math.max(1, wordCount);\n    const avgSentenceLength = wordCount / Math.max(1, sentences.length);\n    const writingStyle = this.determineWritingStyle(avgWordLength, avgSentenceLength);\n    \n    // Advanced metrics\n    const longWords = words.filter(w => w.length > 7);\n    const vocabRatio = longWords.length / Math.max(1, wordCount);\n    const vocabLevel = vocabRatio > 0.2 ? 'Advanced' : vocabRatio > 0.1 ? 'Moderate' : 'Basic';\n    const sentenceStructure = avgSentenceLength > 20 ? 'Complex' : avgSentenceLength > 12 ? 'Varied' : 'Simple';\n    const clarityScore = Math.max(50, Math.min(100, 120 - avgSentenceLength * 2));\n    \n    const vividWords = ['exciting', 'surprising', 'dramatic', 'incredible', 'unexpected', 'strange', 'intense'];\n    const engagementCount = words.filter(w => vividWords.includes(w.toLowerCase())).length;\n    const engagementScore = Math.min(100, 70 + engagementCount * 3);\n    \n    return {\n      wordCount,\n      readingTime,\n      gradeLevel,\n      writingStyle,\n      vocabLevel,\n      sentenceStructure,\n      clarityScore: Math.round(clarityScore),\n      engagementScore\n    };\n  }\n  \n  // Update analysis display in the UI\n  updateAnalysisDisplay(analysis) {\n    const {\n      wordCount,\n      readingTime,\n      gradeLevel,\n      writingStyle,\n      vocabularyLevel,\n      sentenceStructure,\n      clarityScore,\n      engagementScore,\n      recommendationsContainer\n    } = this.elements;\n    \n    // Update basic metrics\n    if (wordCount) wordCount.textContent = analysis.wordCount;\n    if (readingTime) readingTime.textContent = `${analysis.readingTime} min`;\n    if (gradeLevel) gradeLevel.textContent = analysis.gradeLevel;\n    if (writingStyle) writingStyle.textContent = analysis.writingStyle;\n    \n    // Update advanced metrics\n    if (vocabularyLevel) vocabularyLevel.textContent = analysis.vocabLevel;\n    if (sentenceStructure) sentenceStructure.textContent = analysis.sentenceStructure;\n    if (clarityScore) clarityScore.textContent = `${analysis.clarityScore}%`;\n    if (engagementScore) engagementScore.textContent = `${analysis.engagementScore}%`;\n    \n    // Update recommendations\n    if (recommendationsContainer) {\n      recommendationsContainer.innerHTML = `\n        <ul>\n          <li>Use more vivid and specific vocabulary.</li>\n          <li>Vary sentence structure for better rhythm.</li>\n          <li>Simplify long or complex sentences.</li>\n        </ul>\n      `;\n    }\n  }\n  \n  // Count syllables in text\n  countSyllables(text) {\n    const words = text.trim().toLowerCase().split(/\\s+/);\n    let count = 0;\n    \n    words.forEach(word => {\n      word = word.replace(/[^a-z]/g, '');\n      if (word.length <= 3) {\n        count += 1;\n        return;\n      }\n      count += word.replace(/[^aeiouy]+/g, ' ').trim().split(/\\s+/).length;\n    });\n    \n    return count;\n  }\n  \n  // Determine writing style based on word and sentence length\n  determineWritingStyle(avgWordLength, avgSentenceLength) {\n    if (avgWordLength > 5 && avgSentenceLength > 20) return 'Academic';\n    else if (avgWordLength < 4 && avgSentenceLength < 15) return 'Conversational';\n    else return 'Balanced';\n  }\n  \n  // Update analysis tab with new text\n  updateAnalysisTab(text) {\n    this.analyzeText(text);\n  }\n  \n  // Check if writer appears to be stuck\n  isWriterStuck(text, parsed) {\n    // Check for repetitive words\n    const lastWords = parsed.words.slice(-10);\n    const uniqueWords = new Set(lastWords);\n    if (uniqueWords.size < 5) return true;\n    \n    // Check for long pause in writing\n    const lastUpdate = localStorage.getItem('lastWritingUpdate');\n    if (lastUpdate && Date.now() - lastUpdate > 30000) return true;\n    \n    return false;\n  }\n  \n  // Generate and display writing prompts\n  generateWritingPrompts() {\n    const { promptsContainer, braindumpInput } = this.elements;\n    if (!promptsContainer) return;\n    \n    promptsContainer.innerHTML = '';\n    \n    const prompts = [\n      'What is the main point you want to convey?',\n      'How does this connect to your previous ideas?',\n      'Can you provide an example to illustrate this?',\n      'What would someone who disagrees with you say?',\n      'How does this relate to your overall topic?'\n    ];\n    \n    prompts.forEach(prompt => {\n      const promptElement = document.createElement('div');\n      promptElement.className = 'prompt';\n      promptElement.textContent = prompt;\n      \n      if (braindumpInput) {\n        promptElement.onclick = () => {\n          braindumpInput.value += '\\n\\n' + prompt;\n          braindumpInput.focus();\n        };\n      }\n      \n      promptsContainer.appendChild(promptElement);\n    });\n  }\n  \n  // Notify parent that sidebar is ready\n  notifyParentReady() {\n    window.parent.postMessage({ action: 'sidebarReady' }, '*');\n  }\n}\n\n// Initialize the app when the DOM is ready\ndocument.addEventListener('DOMContentLoaded', () => {\n  new SidebarApp();\n});\n\n\n\n//# sourceURL=webpack://cognito-extension/./js/sidebar.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./js/sidebar.js"]();
/******/ 	
/******/ })()
;
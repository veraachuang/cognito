/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./content.js":
/*!********************!*\
  !*** ./content.js ***!
  \********************/
/***/ ((module) => {

eval("// Create and inject the sidebar iframe\nlet sidebarFrame = null;\nlet sidebarVisible = false;\nlet shadowRoot = null;\nlet docsObserver = null;\nlet genericObserver = null;\nlet layoutDebounceTimer = null;\n\n// Initialize the content script\nconsole.log('Content script initialized');\n\n// Cleanup function for observers and elements\nfunction cleanup() {\n  if (docsObserver) {\n    docsObserver.disconnect();\n    docsObserver = null;\n  }\n  if (genericObserver) {\n    genericObserver.disconnect();\n    genericObserver = null;\n  }\n  if (shadowRoot) {\n    shadowRoot.host.remove();\n    shadowRoot = null;\n  }\n  if (sidebarFrame) {\n    sidebarFrame = null;\n  }\n  sidebarVisible = false;\n}\n\n// Debounce function to prevent rapid layout adjustments\nfunction debounce(func, wait) {\n  return function executedFunction(...args) {\n    const later = () => {\n      layoutDebounceTimer = null;\n      func(...args);\n    };\n    clearTimeout(layoutDebounceTimer);\n    layoutDebounceTimer = setTimeout(later, wait);\n  };\n}\n\nfunction createShadowContainer() {\n  const container = document.createElement('div');\n  container.id = 'cognito-container';\n  shadowRoot = container.attachShadow({ mode: 'open' });\n  document.body.appendChild(container);\n  return shadowRoot;\n}\n\nfunction createSidebar() {\n  if (sidebarFrame) {\n    console.log('Sidebar already exists');\n    return;\n  }\n  \n  console.log('Creating sidebar iframe');\n  \n  // Create shadow DOM if it doesn't exist\n  if (!shadowRoot) {\n    shadowRoot = createShadowContainer();\n  }\n\n  sidebarVisible = false;  // Start with sidebar hidden\n\n  // Create styles for shadow DOM\n  const style = document.createElement('style');\n  style.textContent = `\n    .cognito-sidebar {\n      position: fixed;\n      top: 0;\n      right: 0;\n      width: 350px;\n      height: 100vh;\n      background: white;\n      box-shadow: -2px 0 8px rgba(0, 0, 0, 0.1);\n      z-index: 2147483647;\n      transition: transform 0.3s ease;\n      user-select: none;\n      -webkit-user-select: none;\n      pointer-events: auto;\n      transform: translateX(350px);  // Start hidden\n    }\n    .cognito-content-shift {\n      transition: margin-right 0.3s ease, width 0.3s ease;\n    }\n  `;\n  shadowRoot.appendChild(style);\n\n  // Create sidebar container\n  const sidebarContainer = document.createElement('div');\n  sidebarContainer.className = 'cognito-sidebar';\n  \n  // Create and setup iframe\n  sidebarFrame = document.createElement('iframe');\n  sidebarFrame.src = chrome.runtime.getURL('sidebar.html');\n  sidebarFrame.style.cssText = `\n    width: 100%;\n    height: 100%;\n    border: none;\n    background: white;\n  `;\n  \n  sidebarContainer.appendChild(sidebarFrame);\n  shadowRoot.appendChild(sidebarContainer);\n  \n  console.log('Sidebar iframe created and appended');\n\n  // Add class to body for content shifting\n  document.body.classList.add('cognito-content-shift');\n  \n  // Setup observers for layout adjustment\n  setupDocsObserver();\n  setupGenericObserver();\n}\n\nfunction setupDocsObserver() {\n  if (docsObserver) {\n    docsObserver.disconnect();\n  }\n\n  // Create a one-time observer to wait for the editor to load\n  docsObserver = new MutationObserver((mutations, obs) => {\n    const docsContainer = document.querySelector('.kix-appview-editor');\n    if (docsContainer) {\n      obs.disconnect();\n      \n      // Set up the actual observer for layout changes\n      docsObserver = new MutationObserver(debounce(() => {\n        if (document.querySelector('.kix-appview-editor')) {\n          adjustDocsLayout();\n        }\n      }, 100));\n\n      docsObserver.observe(document.body, {\n        childList: true,\n        subtree: true,\n        attributes: true,\n        attributeFilter: ['style', 'class']\n      });\n    }\n  });\n\n  docsObserver.observe(document.body, { childList: true, subtree: true });\n}\n\nfunction setupGenericObserver() {\n  if (genericObserver) {\n    genericObserver.disconnect();\n  }\n\n  // Add margin to body or main container\n  const mainContainer = document.querySelector('main') || document.querySelector('#main') || document.body;\n  if (mainContainer) {\n    mainContainer.style.transition = 'margin-right 0.3s ease';\n  }\n\n  // Create observer for dynamic content\n  genericObserver = new MutationObserver(debounce(() => {\n    if (sidebarVisible) {\n      adjustGenericLayout();\n    }\n  }, 100));\n\n  genericObserver.observe(document.body, {\n    childList: true,\n    subtree: true,\n    attributes: true,\n    attributeFilter: ['style', 'class']\n  });\n}\n\nfunction adjustDocsLayout() {\n  // Main content containers that need margin and width adjustment\n  const mainContainers = [\n    '.kix-appview-editor',\n    '.docs-toolbar-wrapper',\n    '.docs-titlebar-badges',\n    '.docs-horizontal-ruler',\n    '.docs-menubar',\n    '.docs-header',\n    '.companion-guest-app-switcher-container'\n  ];\n\n  const margin = sidebarVisible ? '350px' : '0';\n  \n  // Adjust main content containers\n  mainContainers.forEach(selector => {\n    const element = document.querySelector(selector);\n    if (element) {\n      if (selector === '.companion-guest-app-switcher-container') {\n        // Special handling for companion container\n        element.style.right = margin;\n        element.style.transition = 'right 0.3s ease';\n      } else {\n        element.style.marginRight = margin;\n        element.style.width = sidebarVisible ? `calc(100% - ${margin})` : '100%';\n        element.style.transition = 'all 0.3s ease';\n      }\n    }\n  });\n\n  // Handle the document page container specifically\n  const pageContainer = document.querySelector('.kix-page');\n  if (pageContainer) {\n    pageContainer.style.marginRight = margin;\n    pageContainer.style.transition = 'margin 0.3s ease';\n  }\n\n  // Adjust Google Docs side panel containers\n  const sidePanelContainers = [\n    '.companion-app-switcher-container',\n    '.companion-guest-app-switcher-container'\n  ];\n\n  sidePanelContainers.forEach(selector => {\n    const container = document.querySelector(selector);\n    if (container) {\n      if (sidebarVisible) {\n        container.style.right = margin;\n        container.style.width = 'var(--companion-app-switcher-width)';\n      } else {\n        container.style.right = '0';\n        container.style.width = '';\n      }\n      container.style.transition = 'right 0.3s ease';\n    }\n  });\n\n  // Adjust toolbar wrapper specifically\n  const toolbarWrapper = document.querySelector('.docs-toolbar-wrapper');\n  if (toolbarWrapper) {\n    toolbarWrapper.style.marginRight = margin;\n    toolbarWrapper.style.width = sidebarVisible ? `calc(100% - ${margin})` : '100%';\n    toolbarWrapper.style.transition = 'all 0.3s ease';\n    \n    // Ensure the inner toolbar elements are properly aligned\n    const innerToolbar = toolbarWrapper.querySelector('.docs-toolbar');\n    if (innerToolbar) {\n      innerToolbar.style.width = '100%';\n      innerToolbar.style.transition = 'all 0.3s ease';\n    }\n  }\n\n  // Handle responsive UI elements\n  if (sidebarVisible) {\n    // Add compact mode class to body\n    document.body.classList.add('docs-size-compact');\n    \n    // Adjust share button to compact mode\n    const shareButtonText = document.querySelector('.docs-share-button-label');\n    if (shareButtonText) {\n      shareButtonText.style.display = 'none';\n    }\n\n    // Make menu bar more compact\n    const menuBar = document.querySelector('.docs-menubar');\n    if (menuBar) {\n      // Adjust menu bar container\n      menuBar.style.padding = '0 4px';\n      \n      // Adjust individual menu items\n      const menuItems = menuBar.querySelectorAll('.goog-menu-button, .docs-menu-button');\n      menuItems.forEach(item => {\n        item.style.padding = '0 3px';\n        item.style.minWidth = '20px';\n        // Hide menu item text, keep only first letter\n        const menuText = item.querySelector('.goog-menu-button-caption, .docs-menu-button-label');\n        if (menuText) {\n          const text = menuText.textContent;\n          if (text && text.length > 1) {\n            menuText.setAttribute('data-full-text', text);\n            menuText.textContent = text[0];\n          }\n        }\n      });\n    }\n\n    // Adjust toolbar buttons to be more compact\n    const toolbarButtons = document.querySelectorAll('.goog-toolbar-button, .docs-toolbar-button');\n    toolbarButtons.forEach(button => {\n      button.style.padding = '0 4px';\n      button.style.margin = '0 1px';\n    });\n\n    // Make header more compact\n    const header = document.querySelector('.docs-titlebar-buttons');\n    if (header) {\n      header.style.gap = '4px';\n      header.style.padding = '0 8px';\n    }\n\n    // Handle side panel toggle buttons\n    const sidePanelToggles = document.querySelectorAll('.companion-collapser-button-container, .companion-guest-collapser-button-container');\n    sidePanelToggles.forEach(toggle => {\n      if (toggle) {\n        toggle.style.right = margin;\n        toggle.style.transition = 'right 0.3s ease';\n      }\n    });\n\n  } else {\n    // Remove compact mode\n    document.body.classList.remove('docs-size-compact');\n    \n    // Restore share button text\n    const shareButtonText = document.querySelector('.docs-share-button-label');\n    if (shareButtonText) {\n      shareButtonText.style.display = '';\n    }\n\n    // Restore menu bar\n    const menuBar = document.querySelector('.docs-menubar');\n    if (menuBar) {\n      // Restore menu bar container\n      menuBar.style.padding = '';\n      \n      // Restore menu items\n      const menuItems = menuBar.querySelectorAll('.goog-menu-button, .docs-menu-button');\n      menuItems.forEach(item => {\n        item.style.padding = '';\n        item.style.minWidth = '';\n        // Restore menu item text\n        const menuText = item.querySelector('.goog-menu-button-caption, .docs-menu-button-label');\n        if (menuText && menuText.hasAttribute('data-full-text')) {\n          menuText.textContent = menuText.getAttribute('data-full-text');\n          menuText.removeAttribute('data-full-text');\n        }\n      });\n    }\n\n    // Restore toolbar buttons\n    const toolbarButtons = document.querySelectorAll('.goog-toolbar-button, .docs-toolbar-button');\n    toolbarButtons.forEach(button => {\n      button.style.padding = '';\n      button.style.margin = '';\n    });\n\n    // Restore header\n    const header = document.querySelector('.docs-titlebar-buttons');\n    if (header) {\n      header.style.gap = '';\n      header.style.padding = '';\n    }\n\n    // Restore side panel toggle buttons\n    const sidePanelToggles = document.querySelectorAll('.companion-collapser-button-container, .companion-guest-collapser-button-container');\n    sidePanelToggles.forEach(toggle => {\n      if (toggle) {\n        toggle.style.right = '0';\n      }\n    });\n  }\n\n  // Also adjust generic layout\n  adjustGenericLayout();\n}\n\nfunction adjustGenericLayout() {\n  const mainContainer = document.querySelector('main') || document.querySelector('#main') || document.body;\n  const margin = sidebarVisible ? '350px' : '0';\n  \n  if (mainContainer) {\n    mainContainer.style.marginRight = margin;\n    mainContainer.style.width = sidebarVisible ? `calc(100% - ${margin})` : '100%';\n  }\n}\n\nfunction toggleSidebar(activeTab = null) {\n  console.log('Toggling sidebar, activeTab:', activeTab);\n  \n  if (!sidebarFrame) {\n    console.log('No sidebar frame found, creating one');\n    createSidebar();\n  }\n\n  sidebarVisible = !sidebarVisible;\n  console.log('Setting sidebar visibility:', sidebarVisible);\n  \n  // Animate sidebar\n  const sidebarContainer = shadowRoot.querySelector('.cognito-sidebar');\n  if (sidebarContainer) {\n    sidebarContainer.style.transform = sidebarVisible ? 'none' : 'translateX(350px)';\n  }\n\n  // Adjust Google Docs layout\n  adjustDocsLayout();\n\n  if (activeTab && sidebarVisible) {\n    console.log('Switching to tab:', activeTab);\n    setTimeout(() => {\n      if (sidebarFrame && sidebarFrame.contentWindow) {\n        sidebarFrame.contentWindow.postMessage({ action: 'switchTab', tab: activeTab }, '*');\n        console.log('Tab switch message sent');\n      } else {\n        console.error('Sidebar frame or contentWindow not available');\n      }\n    }, 300);\n  }\n}\n\n// Listen for extension unload/reload\nwindow.addEventListener('beforeunload', cleanup);\n\n// Handle extension reload\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n  console.log('Content script received message:', request);\n  \n  if (request.action === 'toggleSidebar') {\n    console.log('Handling toggleSidebar action');\n    // Clean up existing instances before creating new ones\n    cleanup();\n    toggleSidebar(request.tab);\n    sendResponse({ success: true });\n  } else {\n    console.log('Unknown action:', request.action);\n    sendResponse({ success: false, error: 'Unknown action' });\n  }\n  \n  return true; // Keep the message channel open for async response\n});\n\n// Listen for messages from the sidebar iframe\nwindow.addEventListener('message', (event) => {\n  // Make sure the message is from our sidebar\n  console.log('Received message event:', event.data);\n  console.log('Event source:', event.source);\n  console.log('Sidebar frame:', sidebarFrame?.contentWindow);\n  \n  if (event.source !== sidebarFrame?.contentWindow) {\n    console.log('Message source does not match sidebar frame');\n    return;\n  }\n\n  const { action, data } = event.data;\n  console.log('Processing action:', action, 'with data:', data);\n\n  switch (action) {\n    case 'closeSidebar':\n      console.log('Handling closeSidebar action');\n      toggleSidebar();\n      break;\n    case 'uploadFiles':\n      console.log('Handling uploadFiles action');\n      handleFileUpload(data.files);\n      break;\n    case 'applyOutline':\n      console.log('Handling applyOutline action');\n      console.log('Raw outline data:', data.outline);\n      \n      // Ensure outline data is properly structured\n      if (!data.outline) {\n        console.error('No outline data provided');\n        return;\n      }\n\n      // Parse the outline data, handling both string and array formats\n      let title = '';\n      let keyPoints = [];\n      \n      if (typeof data.outline === 'string') {\n        // If it's a single string, use it as the title\n        title = data.outline;\n      } else if (Array.isArray(data.outline)) {\n        // If it's an array, first element is title, rest are key points\n        title = data.outline[0] || '';\n        keyPoints = data.outline.slice(1) || [];\n      } else if (typeof data.outline === 'object') {\n        // If it's an object with title and points\n        title = data.outline.title || '';\n        keyPoints = data.outline.points || [];\n      }\n\n      const parsedOutline = {\n        sections: [{\n          title: title,\n          key_points: Array.isArray(keyPoints) ? keyPoints.map(point => point.toString().trim()) : []\n        }]\n      };\n      \n      console.log('Parsed outline:', parsedOutline);\n      integration.applyOutlineToDocument(parsedOutline);\n      break;\n    case 'getCursorPosition':\n      console.log('Handling getCursorPosition action');\n      const position = getCursorPosition();\n      sidebarFrame.contentWindow.postMessage({\n        action: 'cursorPosition',\n        position: position\n      }, '*');\n      break;\n    default:\n      console.log('Unknown action received:', action);\n  }\n});\n\n// Function to handle file uploads\nasync function handleFileUpload(files) {\n  console.log('Starting file upload');\n  const formData = new FormData();\n  files.forEach(file => formData.append('files', file));\n\n  try {\n    const response = await fetch('http://localhost:5000/api/upload', {\n      method: 'POST',\n      body: formData\n    });\n    \n    const result = await response.json();\n    console.log('Upload successful:', result);\n    sidebarFrame.contentWindow.postMessage({\n      action: 'uploadComplete',\n      success: true,\n      data: result\n    }, '*');\n  } catch (error) {\n    console.error('Upload failed:', error);\n    sidebarFrame.contentWindow.postMessage({\n      action: 'uploadComplete',\n      success: false,\n      error: error.message\n    }, '*');\n  }\n}\n\n// Function to get cursor position in Google Doc\nfunction getCursorPosition() {\n  const selection = window.getSelection();\n  if (!selection.rangeCount) return null;\n\n  const range = selection.getRangeAt(0);\n  const rect = range.getBoundingClientRect();\n  \n  return {\n    x: rect.left,\n    y: rect.top,\n    position: selection.toString()\n  };\n}\n\n// Function to apply the generated outline to the Google Doc\nfunction applyOutlineToDoc(outline, cursorPosition) {\n  const doc = document.querySelector('div[contenteditable=\"true\"]');\n  if (!doc) return;\n\n  // Create outline text\n  const outlineText = outline.sections.map((section, index) => {\n    const keyPoints = section.key_points.map((point, i) => `  ${i + 1}. ${point}`).join('\\n');\n    return `${index + 1}. ${section.title}\\n${keyPoints}`;\n  }).join('\\n\\n');\n  \n  // Create a new div with the outline\n  const outlineElement = document.createElement('div');\n  outlineElement.textContent = outlineText;\n  \n  if (cursorPosition && cursorPosition.node) {\n    // Insert at cursor position\n    const range = document.createRange();\n    range.setStart(cursorPosition.node, cursorPosition.offset);\n    range.insertNode(outlineElement);\n  } else {\n    // Insert at the beginning\n    doc.insertBefore(outlineElement, doc.firstChild);\n  }\n}\n\n// Unique prefix for scoped class names\nconst CLASS_PREFIX = 'cognito-ext';\n\nclass GoogleDocsIntegration {\n    constructor() {\n        this.sidebarFrame = null;\n        this.docIframe = null;\n        this.observer = null;\n        this.isInitialized = false;\n        this.initialize().catch(console.error);\n    }\n\n    async initialize() {\n        if (this.isInitialized) return;\n        \n        // Wait for Google Docs to fully load\n        await this.waitForDocsLoad();\n        \n        // Initialize components\n        this.injectSidebar();\n        this.setupDocumentObserver();\n        this.adjustDocsUI();\n        \n        // Setup message listeners\n        this.setupMessageHandlers();\n        \n        this.isInitialized = true;\n    }\n\n    async waitForDocsLoad() {\n        return new Promise(resolve => {\n            const checkForIframe = () => {\n                // Google Docs main editor iframe\n                this.docIframe = document.querySelector('iframe.docs-editor-container');\n                \n                if (this.docIframe?.contentDocument?.body) {\n                    resolve();\n                } else {\n                    setTimeout(checkForIframe, 100);\n                }\n            };\n            checkForIframe();\n        });\n    }\n\n    injectSidebar() {\n        // Create sidebar iframe\n        this.sidebarFrame = document.createElement('iframe');\n        this.sidebarFrame.src = chrome.runtime.getURL('frontend/sidebar.html');\n        this.sidebarFrame.className = `${CLASS_PREFIX}-sidebar`;\n        \n        // Apply sidebar styles\n        Object.assign(this.sidebarFrame.style, {\n            position: 'fixed',\n            top: '0',\n            right: '0',\n            width: '300px',\n            height: '100vh',\n            border: 'none',\n            backgroundColor: '#ffffff',\n            boxShadow: '-2px 0 5px rgba(0, 0, 0, 0.1)',\n            zIndex: '9999'\n        });\n\n        // Inject sidebar into page\n        document.body.appendChild(this.sidebarFrame);\n    }\n\n    adjustDocsUI() {\n        // Push Google Docs UI to the left\n        const docsContainer = document.querySelector('.docs-editor-container').parentElement;\n        if (docsContainer) {\n            Object.assign(docsContainer.style, {\n                marginRight: '300px',\n                width: 'calc(100% - 300px)'\n            });\n        }\n\n        // Adjust other Google Docs elements\n        const topBar = document.getElementById('docs-chrome');\n        if (topBar) {\n            Object.assign(topBar.style, {\n                marginRight: '300px',\n                width: 'calc(100% - 300px)'\n            });\n        }\n    }\n\n    setupDocumentObserver() {\n        // Create MutationObserver to track document changes\n        this.observer = new MutationObserver(mutations => {\n            this.handleDocumentChanges(mutations);\n        });\n\n        // Start observing the document body\n        const config = {\n            childList: true,\n            subtree: true,\n            characterData: true\n        };\n\n        if (this.docIframe?.contentDocument?.body) {\n            this.observer.observe(this.docIframe.contentDocument.body, config);\n        }\n    }\n\n    handleDocumentChanges(mutations) {\n        // Debounce the change handler to avoid too frequent updates\n        clearTimeout(this.debounceTimer);\n        this.debounceTimer = setTimeout(() => {\n            const text = this.extractVisibleText();\n            this.notifySidebarOfChanges(text);\n        }, 500);\n    }\n\n    extractVisibleText() {\n        if (!this.docIframe?.contentDocument?.body) return '';\n\n        // Get all text nodes from the document\n        const walker = document.createTreeWalker(\n            this.docIframe.contentDocument.body,\n            NodeFilter.SHOW_TEXT,\n            null,\n            false\n        );\n\n        let text = '';\n        let node;\n        \n        while (node = walker.nextNode()) {\n            // Skip hidden elements\n            if (this.isNodeVisible(node)) {\n                text += node.textContent + ' ';\n            }\n        }\n\n        return text.trim();\n    }\n\n    isNodeVisible(node) {\n        const element = node.parentElement;\n        if (!element) return false;\n\n        const style = window.getComputedStyle(element);\n        return style.display !== 'none' && \n               style.visibility !== 'hidden' && \n               style.opacity !== '0';\n    }\n\n    notifySidebarOfChanges(text) {\n        if (this.sidebarFrame) {\n            this.sidebarFrame.contentWindow.postMessage({\n                action: 'documentChanged',\n                text: text\n            }, '*');\n        }\n    }\n\n    setupMessageHandlers() {\n        // Listen for messages from sidebar\n        window.addEventListener('message', async (event) => {\n            // Verify message origin\n            if (event.source !== this.sidebarFrame?.contentWindow) return;\n\n            const { action, data } = event.data;\n\n            switch (action) {\n                case 'getCursorPosition':\n                    const position = this.getCursorPosition();\n                    event.source.postMessage({\n                        action: 'cursorPosition',\n                        position: position\n                    }, '*');\n                    break;\n\n                case 'applyOutline':\n                    await this.applyOutlineToDocument(data.outline);\n                    break;\n\n                case 'closeSidebar':\n                    this.removeSidebar();\n                    break;\n            }\n        });\n    }\n\n    getCursorPosition() {\n        // Get cursor position from Google Docs\n        const cursor = this.docIframe?.contentDocument?.querySelector('.kix-cursor');\n        if (!cursor) return null;\n\n        const rect = cursor.getBoundingClientRect();\n        return {\n            x: rect.left,\n            y: rect.top,\n            height: rect.height,\n            selectedText: window.getSelection().toString()\n        };\n    }\n\n    // Helper function to insert the styled outline\n    _insertStyledOutline(pageElement, outline) {\n        try {\n            console.log('Inserting outline into page:', pageElement);\n            // Format the outline\n            const formattedOutline = this.formatOutline(outline);\n            console.log('Formatted outline text:', formattedOutline.text);\n\n            // Create the container div for the outline\n            const outlineContainer = document.createElement('div');\n            outlineContainer.className = 'cognito-inserted-outline';\n            Object.assign(outlineContainer.style, {\n                border: '1px solid #e0e0e0',\n                padding: '10px 15px',\n                margin: '10px 0',\n                backgroundColor: '#f9f9f9',\n                borderRadius: '4px',\n                fontFamily: 'Arial, sans-serif', // Ensure consistent font\n                fontSize: '11pt' // Match typical Google Docs font size\n            });\n\n            // Split the text into paragraphs and create elements\n            const paragraphs = formattedOutline.text.split('\\n');\n            paragraphs.forEach(paragraphText => {\n                if (paragraphText.trim()) {\n                    const paragraphElement = document.createElement('div');\n                    paragraphElement.textContent = paragraphText;\n                    paragraphElement.style.marginBottom = '5px';\n                    paragraphElement.style.lineHeight = '1.4'; // Improve readability\n                    outlineContainer.appendChild(paragraphElement);\n                }\n            });\n\n            // Insert the container at the top of the page\n            pageElement.insertBefore(outlineContainer, pageElement.firstChild);\n\n            // Notify success\n            console.log('Outline application completed successfully.');\n            if (this.sidebarFrame?.contentWindow) {\n                this.sidebarFrame.contentWindow.postMessage({\n                    action: 'outlineApplied',\n                    success: true\n                }, '*');\n            }\n        } catch (error) {\n             console.error('Error during outline insertion:', error);\n             console.error('Error stack:', error.stack);\n             if (this.sidebarFrame?.contentWindow) {\n                 this.sidebarFrame.contentWindow.postMessage({\n                     action: 'outlineApplied',\n                     success: false,\n                     error: `Error during insertion: ${error.message}`\n                 }, '*');\n             }\n        }\n    }\n\n    async applyOutlineToDocument(outline) {\n        console.log('Starting applyOutlineToDocument');\n        console.log('Outline data:', outline);\n\n        try {\n            // Find the editor directly\n            const editor = document.querySelector('.kix-appview-editor');\n            if (!editor) {\n                // If editor isn't found immediately, we might need to wait for it too,\n                // but for now, we'll assume it should be present or throw.\n                throw new Error('Google Docs editor (.kix-appview-editor) not found.');\n            }\n            console.log('Found editor:', editor);\n\n            // Check if the page element already exists\n            const page = editor.querySelector('.kix-page');\n            if (page) {\n                console.log('.kix-page found immediately.');\n                this._insertStyledOutline(page, outline);\n            } else {\n                console.log('.kix-page not found immediately. Setting up MutationObserver...');\n                // If page doesn't exist, wait for it with a MutationObserver\n                const observer = new MutationObserver((mutations, obs) => {\n                    for (const mutation of mutations) {\n                        if (mutation.addedNodes.length > 0) {\n                            for (const node of mutation.addedNodes) {\n                                // Check if the added node is the page or contains the page\n                                if (node.nodeType === Node.ELEMENT_NODE) {\n                                    const foundPage = (node.matches && node.matches('.kix-page')) \n                                                      ? node \n                                                      : node.querySelector('.kix-page');\n                                    \n                                    if (foundPage) {\n                                        console.log('.kix-page found by MutationObserver.');\n                                        obs.disconnect(); // Stop observing once found\n                                        this._insertStyledOutline(foundPage, outline); \n                                        return; // Exit once handled\n                                    }\n                                }\n                            }\n                        }\n                    }\n                });\n\n                // Start observing the editor for child additions\n                observer.observe(document.body, { \n                    childList: true, \n                    subtree: true \n                });\n                \n                console.log('MutationObserver is waiting for .kix-page...');\n            }\n\n        } catch (error) {\n            // Catch errors finding the editor or setting up the observer\n            console.error('Error applying outline:', error);\n            console.error('Error stack:', error.stack);\n            if (this.sidebarFrame?.contentWindow) {\n                this.sidebarFrame.contentWindow.postMessage({\n                    action: 'outlineApplied',\n                    success: false,\n                    error: error.message\n                }, '*');\n            }\n        }\n    }\n\n    formatOutline(outline) {\n        console.log('Starting outline formatting with outline:', outline);\n        \n        // Validate outline structure\n        if (!outline || typeof outline !== 'object') {\n            console.error('Invalid outline object:', outline);\n            throw new Error('Invalid outline object provided');\n        }\n\n        let text = '';\n\n        // Process each section\n        outline.sections.forEach((section, sectionIndex) => {\n            // Section title with proper formatting\n            text += `${section.title}\\n\\n`;\n\n            // Key points with bullet points and proper formatting\n            if (Array.isArray(section.key_points) && section.key_points.length > 0) {\n                section.key_points.forEach(point => {\n                    if (point && typeof point === 'string') {\n                        text += `• ${point.trim()}\\n`;\n                    }\n                });\n            }\n\n            // Add extra newline between sections\n            text += '\\n';\n        });\n\n        // Ensure there's always some content\n        if (!text.trim()) {\n            text = 'Empty Outline\\n\\n• No content provided\\n';\n        }\n\n        console.log('Formatted outline text:', text);\n\n        return {\n            text: text,\n            html: text\n        };\n    }\n\n    // Helper method to simulate typing\n    async simulateTyping(element, text) {\n        for (let char of text) {\n            const event = new InputEvent('textInput', {\n                data: char,\n                bubbles: true,\n                cancelable: true\n            });\n            element.dispatchEvent(event);\n            await new Promise(resolve => setTimeout(resolve, 10)); // Small delay between characters\n        }\n    }\n\n    notifySidebarOfChanges(message) {\n        console.log('Notifying sidebar of changes:', message);\n        if (this.sidebarFrame?.contentWindow) {\n            this.sidebarFrame.contentWindow.postMessage(message, '*');\n        } else {\n            console.error('Sidebar frame or contentWindow not available for notification');\n        }\n    }\n\n    removeSidebar() {\n        if (this.sidebarFrame) {\n            this.sidebarFrame.remove();\n            this.sidebarFrame = null;\n        }\n\n        // Restore original Google Docs UI\n        const docsContainer = document.querySelector('.docs-editor-container').parentElement;\n        if (docsContainer) {\n            Object.assign(docsContainer.style, {\n                marginRight: '0',\n                width: '100%'\n            });\n        }\n\n        const topBar = document.getElementById('docs-chrome');\n        if (topBar) {\n            Object.assign(topBar.style, {\n                marginRight: '0',\n                width: '100%'\n            });\n        }\n\n        // Stop observing\n        if (this.observer) {\n            this.observer.disconnect();\n        }\n    }\n}\n\n// Initialize the integration\nconst integration = new GoogleDocsIntegration();\n\n// Export for testing\nif ( true && module.exports) {\n    module.exports = GoogleDocsIntegration;\n} \n\n//# sourceURL=webpack://cognito-extension/./content.js?");
eval("// content.js\nlet sidebarFrame = null;\nlet sidebarVisible = false;\nlet lastText = \"\";\nlet canvasPollingInterval;\n\nconsole.log('[Cognito] Content script initialized');\n\nfunction createSidebar() {\n  if (sidebarFrame) return;\n\n  sidebarFrame = document.createElement('iframe');\n  sidebarFrame.src = chrome.runtime.getURL('sidebar.html');\n  sidebarFrame.id = 'cognito-sidebar';\n  sidebarFrame.style.cssText = `\n    position: fixed;\n    top: 0;\n    right: -350px;\n    width: 350px;\n    height: 100vh;\n    border: none;\n    z-index: 9999;\n    transition: right 0.3s ease;\n  `;\n  document.body.appendChild(sidebarFrame);\n}\n\nfunction toggleSidebar(activeTab = null) {\n  if (!sidebarFrame) createSidebar();\n\n  sidebarVisible = !sidebarVisible;\n  sidebarFrame.style.right = sidebarVisible ? '0' : '-350px';\n\n  const docsContent = document.querySelector('.docs-editor-container');\n  const docsEditor = document.querySelector('.docs-editor');\n  const docsContentWrapper = document.querySelector('.docs-content-wrapper');\n\n  [docsContent, docsEditor, docsContentWrapper].forEach(el => {\n    if (el) {\n      el.style.width = sidebarVisible ? 'calc(100% - 350px)' : '100%';\n      el.style.transition = 'width 0.3s ease';\n    }\n  });\n\n  if (sidebarVisible) {\n    setTimeout(() => startCanvasModePolling(), 1000);\n  } else {\n    clearInterval(canvasPollingInterval);\n  }\n\n  if (activeTab && sidebarVisible) {\n    setTimeout(() => {\n      if (sidebarFrame?.contentWindow) {\n        sidebarFrame.contentWindow.postMessage({ action: 'switchTab', tab: activeTab }, '*');\n      }\n    }, 300);\n  }\n}\n\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n  if (request.action === 'toggleSidebar') {\n    toggleSidebar(request.tab);\n    sendResponse({ success: true });\n  } else if (request.action === 'fetchDocText') {\n    const text = getVisibleGoogleDocsText();\n    sendResponse({ success: true, text });\n  } else {\n    sendResponse({ success: false, error: 'Unknown action' });\n  }\n  return true;\n});\n\nwindow.addEventListener('message', (event) => {\n  if (event.source !== sidebarFrame?.contentWindow) return;\n  const { action, data } = event.data;\n\n  switch (action) {\n    case 'closeSidebar':\n      toggleSidebar();\n      break;\n    case 'uploadFiles':\n      handleFileUpload(data.files);\n      break;\n    case 'applyOutline':\n      applyOutlineToDoc(data.outline, data.cursor_position);\n      break;\n    case 'getCursorPosition':\n      const position = getCursorPosition();\n      sidebarFrame.contentWindow.postMessage({\n        action: 'cursorPosition',\n        position: position\n      }, '*');\n      break;\n  }\n});\n\nfunction handleFileUpload(files) {\n  console.log('[Cognito] Received files:', files);\n}\n\nfunction getCursorPosition() {\n  const selection = window.getSelection();\n  if (!selection.rangeCount) return null;\n  const range = selection.getRangeAt(0);\n  const rect = range.getBoundingClientRect();\n  return {\n    x: rect.left,\n    y: rect.top,\n    node: range.startContainer,\n    offset: range.startOffset\n  };\n}\n\nfunction applyOutlineToDoc(outline, cursorPosition) {\n  const doc = document.querySelector('div[contenteditable=\"true\"]');\n  if (!doc) return;\n\n  const outlineText = outline.sections.map((section, index) => {\n    const keyPoints = section.key_points.map((point, i) => `  ${i + 1}. ${point}`).join('\\n');\n    return `${index + 1}. ${section.title}\\n${keyPoints}`;\n  }).join('\\n\\n');\n\n  const outlineElement = document.createElement('div');\n  outlineElement.textContent = outlineText;\n\n  if (cursorPosition && cursorPosition.node) {\n    const range = document.createRange();\n    range.setStart(cursorPosition.node, cursorPosition.offset);\n    range.insertNode(outlineElement);\n  } else {\n    doc.insertBefore(outlineElement, doc.firstChild);\n  }\n}\n\nfunction getVisibleGoogleDocsText() {\n  const container = document.querySelector('.kix-appview');\n  if (!container) {\n    console.warn('[Cognito] No .kix-appview container found');\n    return '';\n  }\n\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT, {\n    acceptNode: (node) => {\n      const text = node.textContent.trim();\n      return text ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;\n    }\n  });\n\n  let text = '';\n  while (walker.nextNode()) {\n    text += walker.currentNode.textContent + ' ';\n  }\n\n  text = text.replace(/\\s+/g, ' ').trim();\n  if (!text) console.warn('[Cognito] Still found no text in doc');\n  return text;\n}\n\n\nfunction startCanvasModePolling() {\n  clearInterval(canvasPollingInterval);\n\n  canvasPollingInterval = setInterval(() => {\n    const rawText = getVisibleGoogleDocsText();\n    const text = rawText.replace(/\\s+/g, ' ').trim();\n\n    // Always log (optional for debug)\n    console.log('[Cognito] Polling text:', text.slice(0, 100));\n\n    const wordCount = text.split(/\\s+/).length;\n    const readingTime = Math.ceil(wordCount / 200);\n\n    // Always send message, even if text is the same\n    if (sidebarFrame?.contentWindow) {\n      sidebarFrame.contentWindow.postMessage({\n        source: 'cognito-content',\n        action: 'liveTextUpdate',\n        data: text,\n        features: {\n          wordCount,\n          readingTime: `${readingTime} min`\n        }\n      }, '*');\n\n      console.log('[Cognito] Sent live text update');\n    }\n\n    // Save lastText if needed for fallback\n    lastText = text;\n  }, 2000);\n}\n\n\n\n//# sourceURL=webpack://cognito-extension/./content.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./content.js");
/******/ 	
/******/ })()
;
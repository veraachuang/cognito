/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./content.js":
/*!********************!*\
  !*** ./content.js ***!
  \********************/
/***/ (() => {

eval("// Create and inject the sidebar iframe\nlet sidebarFrame = null;\nlet sidebarVisible = false;\n\n// Initialize the content script\nconsole.log('Content script initialized');\n\nfunction createSidebar() {\n  if (sidebarFrame) {\n    console.log('Sidebar already exists');\n    return;\n  }\n  \n  console.log('Creating sidebar iframe');\n  sidebarFrame = document.createElement('iframe');\n  sidebarFrame.src = chrome.runtime.getURL('sidebar.html');\n  sidebarFrame.id = 'cognito-sidebar';\n  sidebarFrame.style.cssText = `\n    position: fixed;\n    top: 0;\n    right: -350px;\n    width: 350px;\n    height: 100vh;\n    border: none;\n    z-index: 9999;\n    transition: right 0.3s ease;\n  `;\n  document.body.appendChild(sidebarFrame);\n  console.log('Sidebar iframe created and appended');\n}\n\nfunction toggleSidebar(activeTab = null) {\n  console.log('Toggling sidebar, activeTab:', activeTab);\n  \n  if (!sidebarFrame) {\n    console.log('No sidebar frame found, creating one');\n    createSidebar();\n  }\n\n  sidebarVisible = !sidebarVisible;\n  console.log('Setting sidebar visibility:', sidebarVisible);\n  sidebarFrame.style.right = sidebarVisible ? '0' : '-350px';\n\n  // Adjust the Google Docs layout\n  const docsContent = document.querySelector('.docs-editor-container');\n  const docsEditor = document.querySelector('.docs-editor');\n  const docsContentWrapper = document.querySelector('.docs-content-wrapper');\n  \n  if (docsContent) {\n    docsContent.style.width = sidebarVisible ? 'calc(100% - 350px)' : '100%';\n    docsContent.style.transition = 'width 0.3s ease';\n  }\n  \n  if (docsEditor) {\n    docsEditor.style.width = sidebarVisible ? 'calc(100% - 350px)' : '100%';\n    docsEditor.style.transition = 'width 0.3s ease';\n  }\n  \n  if (docsContentWrapper) {\n    docsContentWrapper.style.width = sidebarVisible ? 'calc(100% - 350px)' : '100%';\n    docsContentWrapper.style.transition = 'width 0.3s ease';\n  }\n\n  if (activeTab && sidebarVisible) {\n    console.log('Switching to tab:', activeTab);\n    // Wait for the sidebar to be visible before switching tabs\n    setTimeout(() => {\n      if (sidebarFrame && sidebarFrame.contentWindow) {\n        sidebarFrame.contentWindow.postMessage({ action: 'switchTab', tab: activeTab }, '*');\n        console.log('Tab switch message sent');\n      } else {\n        console.error('Sidebar frame or contentWindow not available');\n      }\n    }, 300);\n  }\n}\n\n// Listen for messages from the popup\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n  console.log('Content script received message:', request);\n  \n  if (request.action === 'toggleSidebar') {\n    console.log('Handling toggleSidebar action');\n    toggleSidebar(request.tab);\n    sendResponse({ success: true });\n  } else {\n    console.log('Unknown action:', request.action);\n    sendResponse({ success: false, error: 'Unknown action' });\n  }\n  \n  return true; // Keep the message channel open for async response\n});\n\n// Listen for messages from the sidebar iframe\nwindow.addEventListener('message', (event) => {\n  // Make sure the message is from our sidebar\n  if (event.source !== sidebarFrame?.contentWindow) return;\n\n  const { action, data } = event.data;\n\n  switch (action) {\n    case 'closeSidebar':\n      toggleSidebar();\n      break;\n    case 'uploadFiles':\n      handleFileUpload(data.files);\n      break;\n    case 'applyOutline':\n      applyOutlineToDoc(data.outline, data.cursor_position);\n      break;\n    case 'getCursorPosition':\n      const position = getCursorPosition();\n      sidebarFrame.contentWindow.postMessage({\n        action: 'cursorPosition',\n        position: position\n      }, '*');\n      break;\n  }\n});\n\n// Function to handle file uploads\nasync function handleFileUpload(files) {\n  console.log('Starting file upload');\n  const formData = new FormData();\n  files.forEach(file => formData.append('files', file));\n\n  try {\n    const response = await fetch('http://localhost:5000/api/upload', {\n      method: 'POST',\n      body: formData\n    });\n    \n    const result = await response.json();\n    console.log('Upload successful:', result);\n    sidebarFrame.contentWindow.postMessage({\n      action: 'uploadComplete',\n      success: true,\n      data: result\n    }, '*');\n  } catch (error) {\n    console.error('Upload failed:', error);\n    sidebarFrame.contentWindow.postMessage({\n      action: 'uploadComplete',\n      success: false,\n      error: error.message\n    }, '*');\n  }\n}\n\n// Function to get cursor position in Google Doc\nfunction getCursorPosition() {\n  const selection = window.getSelection();\n  if (!selection.rangeCount) return null;\n\n  const range = selection.getRangeAt(0);\n  const rect = range.getBoundingClientRect();\n  \n  return {\n    x: rect.left,\n    y: rect.top,\n    node: range.startContainer,\n    offset: range.startOffset\n  };\n}\n\n// Function to apply the generated outline to the Google Doc\nfunction applyOutlineToDoc(outline, cursorPosition) {\n  const doc = document.querySelector('div[contenteditable=\"true\"]');\n  if (!doc) return;\n\n  // Create outline text\n  const outlineText = outline.sections.map((section, index) => {\n    const keyPoints = section.key_points.map((point, i) => `  ${i + 1}. ${point}`).join('\\n');\n    return `${index + 1}. ${section.title}\\n${keyPoints}`;\n  }).join('\\n\\n');\n  \n  // Create a new div with the outline\n  const outlineElement = document.createElement('div');\n  outlineElement.textContent = outlineText;\n  \n  if (cursorPosition && cursorPosition.node) {\n    // Insert at cursor position\n    const range = document.createRange();\n    range.setStart(cursorPosition.node, cursorPosition.offset);\n    range.insertNode(outlineElement);\n  } else {\n    // Insert at the beginning\n    doc.insertBefore(outlineElement, doc.firstChild);\n  }\n} \n\n//# sourceURL=webpack://cognito-extension/./content.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./content.js"]();
/******/ 	
/******/ })()
;
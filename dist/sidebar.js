/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./sidebar.js":
/*!********************!*\
  !*** ./sidebar.js ***!
  \********************/
/***/ (() => {

eval("document.addEventListener('DOMContentLoaded', () => {\n  // Elements\n  const closeBtn = document.getElementById('close-sidebar');\n  const tabButtons = document.querySelectorAll('.tab-button');\n  const tabPanels = document.querySelectorAll('.tab-panel');\n  const uploadDropzone = document.getElementById('upload-dropzone');\n  const fileInput = document.getElementById('file-input');\n  const uploadButton = document.getElementById('upload-button');\n  const uploadedFiles = document.getElementById('uploaded-files');\n  const braindumpInput = document.getElementById('braindump-input');\n  const analyzeButton = document.getElementById('analyze-button');\n  const regenerateOutline = document.getElementById('regenerate-outline');\n  const applyOutline = document.getElementById('apply-outline');\n  const outlineContainer = document.getElementById('outline-container');\n\n  // Initialize active tab\n  let activeTab = 'upload';\n\n  // Close sidebar\n  closeBtn.addEventListener('click', () => {\n    window.parent.postMessage({ action: 'closeSidebar' }, '*');\n  });\n\n  // Tab switching\n  tabButtons.forEach(button => {\n    button.addEventListener('click', () => {\n      const tabId = button.dataset.tab;\n      switchTab(tabId);\n    });\n  });\n\n  function switchTab(tabId) {\n    // Update active tab state\n    activeTab = tabId;\n\n    // Update button states\n    tabButtons.forEach(btn => {\n      if (btn.dataset.tab === tabId) {\n        btn.classList.add('active');\n      } else {\n        btn.classList.remove('active');\n      }\n    });\n    \n    // Update panel visibility\n    tabPanels.forEach(panel => {\n      if (panel.id === tabId) {\n        panel.classList.add('active');\n        panel.style.display = 'block';\n      } else {\n        panel.classList.remove('active');\n        panel.style.display = 'none';\n      }\n    });\n\n    // Notify parent window of tab change\n    window.parent.postMessage({ \n      action: 'tabChanged', \n      tab: tabId \n    }, '*');\n\n    // Initialize tab-specific functionality\n    if (tabId === 'braindump') {\n      const text = braindumpInput.value;\n      analyzeText(text);\n    }\n  }\n\n  // Listen for messages from content script\n  window.addEventListener('message', (event) => {\n    const { action, tab } = event.data;\n\n    if (action === 'switchTab' && tab) {\n      switchTab(tab);\n    }\n  });\n\n  // Initialize with default tab\n  switchTab(activeTab);\n\n  // File upload handling\n  uploadButton.addEventListener('click', () => {\n    fileInput.click();\n  });\n\n  fileInput.addEventListener('change', (e) => {\n    handleFiles(e.target.files);\n  });\n\n  // Drag and drop handling\n  uploadDropzone.addEventListener('dragover', (e) => {\n    e.preventDefault();\n    uploadDropzone.classList.add('drag-over');\n  });\n\n  uploadDropzone.addEventListener('dragleave', () => {\n    uploadDropzone.classList.remove('drag-over');\n  });\n\n  uploadDropzone.addEventListener('drop', (e) => {\n    e.preventDefault();\n    uploadDropzone.classList.remove('drag-over');\n    handleFiles(e.dataTransfer.files);\n  });\n\n  function handleFiles(files) {\n    // Display files in the list\n    Array.from(files).forEach(file => {\n      const fileItem = document.createElement('div');\n      fileItem.className = 'file-item';\n      fileItem.innerHTML = `\n        <span class=\"file-icon\">ðŸ“„</span>\n        <span class=\"file-name\">${file.name}</span>\n      `;\n      uploadedFiles.appendChild(fileItem);\n    });\n\n    // Send files to content script\n    window.parent.postMessage({\n      action: 'uploadFiles',\n      data: { files: Array.from(files) }\n    }, '*');\n  }\n\n  // Brain dump and outline generation\n  analyzeButton.addEventListener('click', async () => {\n    const text = braindumpInput.value.trim();\n    if (!text) return;\n\n    try {\n      // First, get the cursor position from the Google Doc\n      const cursorPosition = await getCursorPosition();\n      \n      // Call GPT API to generate outline\n      const response = await fetch('http://127.0.0.1:5000/api/generate-outline', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Accept': 'application/json'\n        },\n        mode: 'cors',\n        body: JSON.stringify({ \n          text,\n          cursor_position: cursorPosition\n        })\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({}));\n        throw new Error(errorData.error || `HTTP error! status: ${response.status}`);\n      }\n\n      const data = await response.json();\n      \n      // Display the generated outline\n      displayOutline(data.outline);\n      \n      // Switch to outline tab\n      switchTab('outline');\n      \n      // Apply the outline to the document\n      window.parent.postMessage({\n        action: 'applyOutline',\n        data: { \n          outline: data.outline,\n          cursor_position: cursorPosition\n        }\n      }, '*');\n    } catch (error) {\n      console.error('Error generating outline:', error);\n      alert('Failed to generate outline. Please check your API key and try again.');\n    }\n  });\n\n  // Function to get cursor position from Google Doc\n  async function getCursorPosition() {\n    return new Promise((resolve) => {\n      window.parent.postMessage({ action: 'getCursorPosition' }, '*');\n      \n      const messageHandler = (event) => {\n        if (event.data.action === 'cursorPosition') {\n          window.removeEventListener('message', messageHandler);\n          resolve(event.data.position);\n        }\n      };\n      \n      window.addEventListener('message', messageHandler);\n    });\n  }\n\n  function displayOutline(outline) {\n    if (!outline || !outline.sections) {\n      outlineContainer.innerHTML = '<p class=\"error\">Failed to generate outline. Please try again.</p>';\n      return;\n    }\n\n    let html = `\n      <div class=\"outline-sections\">\n    `;\n\n    // Add sections\n    outline.sections.forEach((section, index) => {\n      html += `\n        <div class=\"outline-section\">\n          <h3>${index + 1}. ${section.title}</h3>\n          <ul>\n            ${section.key_points.map(point => `<li>${point}</li>`).join('')}\n          </ul>\n          ${section.suggested_length ? \n            `<p class=\"suggested-length\">Suggested length: ~${section.suggested_length} words</p>` : ''}\n        </div>\n      `;\n    });\n\n    html += '</div>';\n    outlineContainer.innerHTML = html;\n  }\n\n  regenerateOutline.addEventListener('click', () => {\n    analyzeButton.click();\n  });\n\n  applyOutline.addEventListener('click', () => {\n    const outlineItems = Array.from(outlineContainer.children)\n      .map(p => p.textContent.replace(/^\\d+\\.\\s/, ''));\n\n    window.parent.postMessage({\n      action: 'applyOutline',\n      data: { outline: outlineItems }\n    }, '*');\n  });\n\n  // Writing Analysis Functions\n  function analyzeText(text) {\n    // Basic text analysis\n    const wordCount = text.trim().split(/\\s+/).length;\n    const readingTime = Math.ceil(wordCount / 200); // Assuming 200 words per minute\n    const gradeLevel = calculateGradeLevel(text);\n    const writingStyle = analyzeWritingStyle(text);\n\n    // Update metrics\n    document.getElementById('word-count').textContent = wordCount;\n    document.getElementById('reading-time').textContent = `${readingTime} min`;\n    document.getElementById('grade-level').textContent = gradeLevel;\n    document.getElementById('writing-style').textContent = writingStyle;\n\n    // Generate prompts if writer is stuck\n    if (isWriterStuck(text)) {\n      generateWritingPrompts(text);\n    }\n  }\n\n  function calculateGradeLevel(text) {\n    // Implement Flesch-Kincaid Grade Level formula\n    const words = text.trim().split(/\\s+/);\n    const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);\n    const syllables = countSyllables(text);\n\n    const wordsPerSentence = words.length / sentences.length;\n    const syllablesPerWord = syllables / words.length;\n\n    const gradeLevel = 0.39 * wordsPerSentence + 11.8 * syllablesPerWord - 15.59;\n    return Math.round(gradeLevel);\n  }\n\n  function countSyllables(text) {\n    // Simple syllable counting algorithm\n    const words = text.trim().toLowerCase().split(/\\s+/);\n    let count = 0;\n    \n    words.forEach(word => {\n      word = word.replace(/[^a-z]/g, '');\n      if (word.length <= 3) {\n        count += 1;\n        return;\n      }\n      \n      count += word.replace(/[^aeiouy]+/g, ' ').trim().split(/\\s+/).length;\n    });\n    \n    return count;\n  }\n\n  function analyzeWritingStyle(text) {\n    // Analyze writing style based on various metrics\n    const words = text.trim().split(/\\s+/);\n    const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);\n    \n    const avgWordLength = words.reduce((sum, word) => sum + word.length, 0) / words.length;\n    const avgSentenceLength = words.length / sentences.length;\n    \n    if (avgWordLength > 5 && avgSentenceLength > 20) {\n      return 'Academic';\n    } else if (avgWordLength < 4 && avgSentenceLength < 15) {\n      return 'Conversational';\n    } else {\n      return 'Balanced';\n    }\n  }\n\n  function isWriterStuck(text) {\n    // Detect if writer might be stuck\n    const words = text.trim().split(/\\s+/);\n    const lastWords = words.slice(-10);\n    \n    // Check for repeated words or phrases\n    const uniqueWords = new Set(lastWords);\n    if (uniqueWords.size < 5) {\n      return true;\n    }\n    \n    // Check for long pauses (no new content in last 30 seconds)\n    const lastUpdate = localStorage.getItem('lastWritingUpdate');\n    if (lastUpdate && Date.now() - lastUpdate > 30000) {\n      return true;\n    }\n    \n    return false;\n  }\n\n  function generateWritingPrompts(text) {\n    const promptsContainer = document.getElementById('prompts-container');\n    promptsContainer.innerHTML = '';\n    \n    // Generate context-aware prompts\n    const prompts = [\n      'What is the main point you want to convey?',\n      'How does this connect to your previous ideas?',\n      'Can you provide an example to illustrate this?',\n      'What would someone who disagrees with you say?',\n      'How does this relate to your overall topic?'\n    ];\n    \n    prompts.forEach(prompt => {\n      const promptElement = document.createElement('div');\n      promptElement.className = 'prompt';\n      promptElement.textContent = prompt;\n      promptElement.onclick = () => {\n        const textarea = document.getElementById('braindump-input');\n        textarea.value += '\\n\\n' + prompt;\n        textarea.focus();\n      };\n      promptsContainer.appendChild(promptElement);\n    });\n  }\n\n  // Add event listeners for real-time analysis\n  document.getElementById('braindump-input').addEventListener('input', (e) => {\n    const text = e.target.value;\n    analyzeText(text);\n    localStorage.setItem('lastWritingUpdate', Date.now());\n  });\n\n  // Initialize analysis when tab is switched\n  document.querySelectorAll('.tab-button').forEach(button => {\n    button.addEventListener('click', () => {\n      if (button.dataset.tab === 'braindump') {\n        const text = document.getElementById('braindump-input').value;\n        analyzeText(text);\n      }\n    });\n  });\n}); \n\n//# sourceURL=webpack://cognito-extension/./sidebar.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./sidebar.js"]();
/******/ 	
/******/ })()
;